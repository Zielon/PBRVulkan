#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_NV_ray_tracing : require

// Replaced by Compiler.h
// ====== DEFINES ======

#include "../Common/Structs.glsl"
#include "../Common/Random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureNV TLAS;
layout(binding = 1, rgba32f) uniform image2D AccumulationImage;
layout(binding = 2, rgba8) uniform image2D OutputImage;
layout(binding = 3) readonly uniform UniformBufferObject { Uniform ubo; };

layout(location = 0) rayPayloadNV RayPayload payload;

#include "../Common/Math.glsl"

void main() 
{
	mat4 projInv = inverse(ubo.proj);
	mat4 viewInv = inverse(ubo.view);

	uint  rayFlags = gl_RayFlagsOpaqueNV;
	float tMin     = 0.001;
	float tMax     = 10000.0;

	const uint SPP = ubo.spp; // Samples per pixel
	uint seed = tea(gl_LaunchIDNV.y * gl_LaunchSizeNV.x + gl_LaunchIDNV.x, ubo.frame);
	vec3 color = vec3(0);

	for (uint i = 0; i < SPP; ++i)
	{
		float r1 = rnd(seed);
		float r2 = rnd(seed);

		vec2 jitter = vec2(r1, r2);

		vec2 pixel     = vec2(gl_LaunchIDNV.x, gl_LaunchIDNV.y) + jitter;
		vec2 uv        = (pixel / gl_LaunchSizeNV.xy) * 2.0 - 1.0;
		vec4 origin    = viewInv * vec4(0, 0, 0, 1);
		vec4 target    = projInv * vec4(uv.x, uv.y, 1, 1);
		vec4 direction = viewInv * vec4(normalize(target.xyz), 0);

		// TODO Simulate a lens
		
		payload.seed = seed;

		for (uint j = 0; j <= ubo.maxDepth; ++j)
		{
			payload.depth = j;

			traceNV(TLAS,           // acceleration structure
					rayFlags,       // rayFlags
					0xFF,           // cullMask
					0,              // sbtRecordOffset
					0,              // sbtRecordStride
					0,              // missIndex
					origin.xyz,     // ray origin
					tMin,           // ray min range
					direction.xyz,  // ray direction
					tMax,           // ray max range
					0               // payload (location = 0)
			);

			color += payload.radiance;
		}
	}

	// HDR scale
	vec3 accumulatedColor = ubo.frame > 1 ? imageLoad(AccumulationImage, ivec2(gl_LaunchIDNV.xy)).rbg : vec3(0);
	accumulatedColor += color;	
	imageStore(AccumulationImage, ivec2(gl_LaunchIDNV.xy), vec4(accumulatedColor, 1.0));

	// LDR scale
	color = accumulatedColor / (SPP * ubo.frame);

	#ifdef USE_GAMMA_CORRECTION
	color = pow(toneMap(color, 1.5), vec3(1.0 / 2.2));
	#endif

	imageStore(OutputImage, ivec2(gl_LaunchIDNV.xy), vec4(color, 1.0));
}
